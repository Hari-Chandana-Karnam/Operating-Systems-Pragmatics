// ksr.c, 159
...
...
...
void SyscallSR(void) {   // phase2
      ...
      ...
      ...
      case SYS_GET_RAND:
         ... = ...  (just do this directly)
         ...
      case SYS_LOCK_MUTEX:
         ...
         ...
      case SYS_UNLOCK_MUTEX:
         ...
         ...
      default:
         cons_printf("Kernel Panic: no such syscall!\n");
         breakpoint();
   }

   if run_pid is not NONE, we penalize it by
      a. downgrade its state to READY
      b. moving it to the back of the ready-to-run process queue
      c. reset run_pid (is now NONE)
}
...
...
...
void SleepSR(void) {
   ...
   ...
   ... = ... * 10;  // instad of 100 to speed it up
   ...
   ...
}
...
...
...
void SysLockMutex(void) {   // phase4
   int mutex_id;

   mutex_id = ...

   if(mutex_id == ...) {
      if the lock of the ... is UNLOCKED
         set the lock of the mutex to be LOCKED
      } else {
        suspend the running/calling process: steps 1, 2, 3
      }
   } else {
      cons_printf("Panic: no such mutex ID!\n");
      breakpoint();
  }
}

void SysUnlockMutex(void) {
   int mutex_id, released_pid;

   mutex_id = ...

   if(mutex_id == ...) {
      if(the suspend queue of the mutex is NOT empty) {
        release the 1st process in the suspend queue: steps 1, 2, 3
      } else {
         set the lock of the mutex to be UNLOCKED
      }
   } else {
      cons_printf("Panic: no such mutex ID!\n");
      breakpoint();
  }
}
